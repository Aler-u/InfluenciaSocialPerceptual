dim = c(100,100,3)
)
array(
test,
dim = c(100,100,3)
)[,,1]
array(
test,
dim = c(100,100,3)
)[,,1] == 1
mean(array(
test,
dim = c(100,100,3)
)[,,1] == 1)
array(
test,
dim = c(100,100,3)
)
##Experimental stimulus
rep(
p,
30
)
##Experimental stimulus
rep(
p,
each = 30
)
##Experimental stimulus
rep(
p,
each = 10
)
#
shuffled_vectors_fun <- function(x, vector_length){
sample( #Shuffle the repeated vector
rep( #Repeat a vector of 1 and 0 over 100^2 times
c(1,0), #vector of the integers used to populate the vectors
c(vector_length*x, vector_length*(1-x)) #vector of the absolute number of 1s and 0s to populate the vectors
),
vector_length
)
}
##Training stimulus
#Create 3 vectors of length 100^2 with shuffled 1s and 0s according to the proportions of object p
shuffled_vectors <- sapply(
p, #Iterate over the three color proportions
#Function to generate vectors of length 100^2 with 1s and 0s according to each proportion x (from p) and shuffle it
shuffled_vectors_fun(x, stim_q)
)
#
shuffled_vectors_fun <- function(x, vector_length = stim_q){
sample( #Shuffle the repeated vector
rep( #Repeat a vector of 1 and 0 over 100^2 times
c(1,0), #vector of the integers used to populate the vectors
c(vector_length*x, vector_length*(1-x)) #vector of the absolute number of 1s and 0s to populate the vectors
),
vector_length
)
}
##Training stimulus
#Create 3 vectors of length 100^2 with shuffled 1s and 0s according to the proportions of object p
shuffled_vectors <- sapply(
p, #Iterate over the three color proportions
#Function to generate vectors of length 100^2 with 1s and 0s according to each proportion x (from p) and shuffle it
shuffled_vectors_fun
)
#Create 3000 vectors of length 100^2 with shuffled 1s and 0s, with a different proportion p for each 1000 elements (eg. the first 1000 vectors have proportion 0.45, etc)
sapply(
rep( #Generate a vector of proportions containing 1000 repeated values for each proportion in p
p,
each = 1000
),
shuffled_vectors_fun
)
#Create 3000 vectors of length 100^2 with shuffled 1s and 0s, with a different proportion p for each 1000 elements (eg. the first 1000 vectors have proportion 0.45, etc)
experimental_vectors <- sapply(
rep( #Generate a vector of proportions containing 1000 repeated values for each proportion in p
p,
each = 1000
),
shuffled_vectors_fun
)
experimental_array <- array(
experimental_vectors,
dim = c(100,100,3000)
)
experimental_array[,,1]
sample(c(1:10, 11:20), 3)
sample(c(1:10, 11:20), 3)
sample(c(1:10, 11:20), 3)
#Create 3000 vectors of length 100^2 with shuffled 1s and 0s, with a different proportion p for each 1000 elements (eg. the first 1000 vectors have proportion 0.45, etc)
experimental_vectors <- sapply(
rep( #Generate a vector of proportions containing 1000 repeated values for each proportion in p
p,
each = 100
),
shuffled_vectors_fun
)
experimental_array <- array(
experimental_vectors,
dim = c(100,100,300)
)
sample(100, 30)
sample(101:200, 30)
sample(2, 5, replace = T)
100^2
100*100*300
sample(
c(
sample(100, number_trials),
sample(101:200, number_trials),
sample(201:300, number_trials)
),
number_trials*3
)
sample(
c(
sample(100, 20),
sample(101:200, 20),
sample(201:300, 20)
),
20*3
)
# source pipeline and page layout fns
source("helper_fns_v2.R"); source("page_fns_v2.R")
getwd()
setwd('./Documents/Projects/Doctorado/')
setwd('./Tareas/app_propia/')
ls()
ls('./')
getwd()
ls(getwd())
# source pipeline and page layout fns
source("helper_fns_v2.R"); source("page_fns_v2.R")
data.frame("ITI"= runif(ntr,.7,1)*1000,
'color_truth' = sample(c('orange','blue'), ntr * 3, replace = TRUE),
'trial_matrix' = trial_index_fun(ntr)
)
# sets the number of epxerimental trials you want to use to test the app (must be bigger than 4)
ntr <-  5
data.frame("ITI"= runif(ntr,.7,1)*1000,
'color_truth' = sample(c('orange','blue'), ntr * 3, replace = TRUE),
'trial_matrix' = trial_index_fun(ntr)
)
#Matrix size (100x100)
stim_q <- 100^2
#Colors proportions based on Voss, A., Rothermund, K., & BrandtstÃ¤dter, J. (2008).
p <- c(.45,.47,.49)
shuffled_vectors_fun <- function(x, vector_length = stim_q){
#The function creates a vector with length vector_length consisting of a repetition of 1s and 0s with proportions given by the argument
#x, then it shuffles the vector using the sample function
#Takes two arguments
##x = a proportion (from 0 to 1) corresponding to the amount of 1s in the resulting vector
##vector_length = an integer with the length of the resulting vector, it defaults to the object stim_q
sample( #Shuffle the repeated vector
rep( #Repeat a vector of 1 and 0 over 100^2 times
c(1,0), #vector of the integers used to populate the vectors
c(vector_length*x, vector_length*(1-x)) #vector of the absolute number of 1s and 0s to populate the vectors
),
vector_length
)
}
##Training stimulus
#Create 3 vectors of length 100^2 with shuffled 1s and 0s according to the proportions of object p
shuffled_vectors <- sapply(
p, #Iterate over the three color proportions
#Function to generate vectors of length 100^2 with 1s and 0s according to each proportion x (from p) and shuffle it
shuffled_vectors_fun
)
#Transform the vectors in shuffled_vectors to a 3d array with dimensions 100x100x3
training_stimuli <- array(
shuffled_vectors,
dim = c(100,100,3)
)
#Create 3000 vectors of length 100^2 with shuffled 1s and 0s, with a different proportion p for each 1000 elements (eg. the first 1000 vectors have proportion 0.45, etc)
experimental_vectors <- sapply(
rep( #Generate a vector of proportions containing 1000 repeated values for each proportion in p
p,
each = 100
),
shuffled_vectors_fun
)
#Transformed the shuffled vectors into a 3d array
experimental_array <- array(
experimental_vectors,
dim = c(100,100,300)
)
#Save the results
#save(stims_list,trng_stim_list,color_mat, file = 'stimulus.rda')
save(training_stimuli, experimental_array, file = 'stimulus2.rda')
library(shiny); runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
experimental_array[,,3]
experimental_array[
,
,
3
]
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
rm(experimental_vectors)
rm(shuffled_vectors)
rm(p)
rm(stim_q)
sample(c('orange','blue'), ntr * 3, replace = TRUE)
sample(c('orange','blue'), 10 * 3, replace = TRUE)
ifelse(3 == 'orange', 'blue', 'orange')
ifelse('orange' == 'orange', 'blue', 'orange')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
)
)
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
),
col = c('orange')
)
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
),
col = c('orange', 'orange')
)
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
),
col = c('orange', 'blue')
)
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
),
col = c('orange', 'blue')
)
heatmap(
matrix(
c(rep(1,50),rep(0,50)),10
),
col = c('orange', 'blue')
)
ifelse('orange' == 'orange', 'blue', 'orange')
ifelse('blue' == 'orange', 'blue', 'orange')
heatmap(
matrix(
c(rep(1,50), rep(0,50)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(
c(rep(1,90), rep(0,10)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(
c(rep(0,90), rep(1,10)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(
c(rep(TRUE,90), rep(FALSE,10)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(
c(rep(0,90), rep(1,10)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(
c(rep(1,90), rep(0,10)),
10,
10
),
col = c('red','blue')
)
heatmap(
matrix(c(1,0,1
0,1,0
1,0,1)
),
col = c('red','blue')
)
heatmap(
matrix(c(1,0,1
0,1,0
1,0,1)
),
col = c('red','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1)
),
col = c('red','blue')
)
c(1,0,1,
0,1,0,
1,0,1)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
col = c('red','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
heatmap(
matrix(
c(0,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
runApp('app_v2.R')
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red',NULL)
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red',TRUE)
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('orange','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
heatmap(
matrix(
c(0,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
heatmap(
matrix(
c(1,0,1,
0,1,0,
1,0,1),
3,3
),
Rowv = NA, Colv = NA,
col = c('red','blue')
)
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
sample(c('orange','blue'), ntr * 3, replace = TRUE)
?data.frame
runApp('app_v2.R')
source('~/Documents/Projects/Doctorado/Tareas/app_propia/stimulus_construction.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
View(trngPage)
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
?withProgress
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
?saveData\
saveData
?saveData
?saveData()
saveData
runApp('app_v2.R')
runApp('app_v2.R')
length('aaaa')
?write.table
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
runApp('app_v2.R')
# load experimental and training stimulus
# training stimulus consists of a 3d array with dimensions 100x100xN where the 3rd dimensions (N) corresponds to the number of training trials
# experimental stimulus consists of a named list, each element representing a different proportion of 0s and 1s (see stimulus_construcion.R for details)
stimulus_data <-  readRDS('stimulus2.rda')
# Load pkgs, fns and num lists ====================================================
library(shiny);library(shinyjs);library(shinyWidgets)
# source pipeline and page layout fns
source("helper_fns_v2.R"); source("page_fns_v2.R")
# load experimental and training stimulus
# training stimulus consists of a 3d array with dimensions 100x100xN where the 3rd dimensions (N) corresponds to the number of training trials
# experimental stimulus consists of a named list, each element representing a different proportion of 0s and 1s (see stimulus_construcion.R for details)
stimulus_data <-  readRDS('stimulus2.rda')
getwd()
# load experimental and training stimulus
# training stimulus consists of a 3d array with dimensions 100x100xN where the 3rd dimensions (N) corresponds to the number of training trials
# experimental stimulus consists of a named list, each element representing a different proportion of 0s and 1s (see stimulus_construcion.R for details)
stimulus_data <-  readRDS('stimulus2.rda')
source('~/Documents/Projects/Doctorado/Tareas/app_propia/stimulus_construction.R')
#Save the results
save(training_stimuli, experimental_array, file = 'stimulus2.rda')
#Save the results
saveRDS(training_stimuli, experimental_array, file = 'stimulus2.rda')
#Save the results
saveRDS(training_stimuli,  file = 'training_stimulus.rds')
saveRDS(experimental_array, file = 'experimental_stimulus.rds')
# load experimental and training stimulus
# training stimulus consists of a 3d array with dimensions 100x100xN where the 3rd dimensions (N) corresponds to the number of training trials
# experimental stimulus consists of a named list, each element representing a different proportion of 0s and 1s (see stimulus_construcion.R for details)
training_stimuli <-  readRDS('training_stimulus.rds')
experimental_array <- readRDS('experimental_stimulus.rds')
source('~/Documents/Projects/Doctorado/Tareas/app_propia/stimulus_construction.R')
#Save the results
saveRDS(training_stimuli,  file = 'training_stimulus.rds', version = 2)
saveRDS(experimental_array, file = 'experimental_stimulus.rds', version = 2)
shiny::runApp()
runApp()
shiny::runApp()
runApp('~/Documents/Projects/Doctorado/Tareas/working_app/app_v2.R')
runApp()
